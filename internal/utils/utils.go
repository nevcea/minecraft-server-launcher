package utils

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

var (
	jarFileRegex = regexp.MustCompile(`paper-(.+)-(\d+)\.jar`)
)

func FindJarFile() (string, error) {
	files, err := filepath.Glob("paper-*.jar")
	if err != nil {
		return "", fmt.Errorf("failed to search for JAR files: %w", err)
	}

	if len(files) == 0 {
		return "", nil
	}

	if len(files) == 1 {
		if info, err := os.Stat(files[0]); err == nil && !info.IsDir() {
			return files[0], nil
		}
		return "", nil
	}

	type jarInfo struct {
		path    string
		version string
		build   int
		modTime int64
	}

	jars := make([]jarInfo, 0, len(files))

	for _, file := range files {
		info, err := os.Stat(file)
		if err != nil || info.IsDir() {
			continue
		}

		matches := jarFileRegex.FindStringSubmatch(file)
		if len(matches) == 3 {
			build, err := strconv.Atoi(matches[2])
			if err == nil {
				jars = append(jars, jarInfo{
					path:    file,
					version: matches[1],
					build:   build,
					modTime: info.ModTime().Unix(),
				})
			}
		} else {
			jars = append(jars, jarInfo{
				path:    file,
				version: "",
				build:   0,
				modTime: info.ModTime().Unix(),
			})
		}
	}

	if len(jars) == 0 {
		return "", nil
	}

	sort.Slice(jars, func(i, j int) bool {
		if jars[i].build != jars[j].build {
			return jars[i].build > jars[j].build
		}
		return jars[i].modTime > jars[j].modTime
	})

	return jars[0].path, nil
}

func HandleEULA() error {
	eulaFile := "eula.txt"

	data, err := os.ReadFile(eulaFile)
	if err == nil {
		if strings.Contains(string(data), "eula=true") {
			return nil
		}
	}

	eulaContent := `# By changing the setting below to TRUE you are indicating your agreement to our EULA (https://aka.ms/MinecraftEULA).
# Generated by minecraft-server-launcher
eula=true
`

	if err := os.WriteFile(eulaFile, []byte(eulaContent), 0644); err != nil {
		return fmt.Errorf("failed to write eula.txt: %w", err)
	}

	fmt.Println("[INFO] Automatically accepted Minecraft EULA")
	return nil
}

func Pause() {
	fmt.Print("\nPress Enter to exit...")
	reader := bufio.NewReader(os.Stdin)
	if _, err := reader.ReadBytes('\n'); err != nil {
		_ = err
	}
}
